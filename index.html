<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./style.css">
    <title>Game</title>
  </head>
  <body>
    <div id="buttonContainer">
      <button id="startButton">Start Game</button>
    </div>    
    <canvas id="miCanvas"></canvas>
    <audio src="./modelos/Han.mp3" loop volume="1"></audio>
    <div id="container">
      <span id="scoreLabel">Score: </span>
      <span id="scoreValue">0</span>
      <span id="coinsLabel">Coins: </span>
      <span id="coinsValue">0</span>
      <span id="livesLabel">Lives: </span>
      <span id="livesValue">0</span>
    </div>    
    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "../jsm/"
        }
      }
    </script>
    <script type="module">                
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'

      const startButton = document.getElementById('startButton');
      startButton.addEventListener('click', startGame);
      //Empieza el juego
      function startGame() {
        startButton.removeEventListener('click', startGame);
        startButton.style.display = 'none';
        startButton.addEventListener('click', playAudio);
        // Mostrar el contenedor del score
        const scoreContainer = document.getElementById('container');
        scoreContainer.style.display = 'block';
        const canvas = document.getElementById('miCanvas');
        const cuchao = new Audio('./modelos/cuchao.mp3');
        let objectToFollow;
        let puntos = 0;
        let vidas = 3;
        let monedas = 0;
        const objectsToRemove = [];
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        const scene = new THREE.Scene();
        scene.background = null;
        renderer.setClearColor(0x000000, 0);
        renderer.setClearAlpha;
        //Crear cámara
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(5, 0, 0);

        //Agregar variable de velocidad
        const speed = 10;

        //cámara
        var cam = 1;

        //Crear luz direccional
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 1, 0);
        scene.add(directionalLight);
        const directionalLight3 = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight3.position.set(0, 0, -1);
        scene.add(directionalLight3);

        // Crear una luz direccional que emita luz en la dirección Z
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight2.position.set(0, 0, 1); // dirección de la luz en el eje Z
        directionalLight2.target.position.set(0, 0, 0); // punto hacia donde apunta la luz
        scene.add(directionalLight2);
        scene.add(directionalLight2.target);

        function playAudio() {
          const audio = document.querySelector('audio');
          audio.play();
        }

        //Carretera1
        const carretera = new GLTFLoader();
        carretera.load('./modelos/road1/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const originalMesh = gltf.scene.children[0];

          //Repetir carretera
          const numCopies = 500;
          for (let i = 0; i < numCopies; i++) {
            //Clonar el objeto de malla
            const mesh = originalMesh.clone();

            //Modificar la posición del objeto de malla clonado
            mesh.position.x =-1000 + i * -11710; //Distancia entre cada copia de la carretera

            //Escala el objeto de malla
            mesh.scale.set(80, 80, 80);

            //Mueve el objeto de malla hacia arriba en la escena
            mesh.position.y = 100;

            //Agrega el modelo GLTF a la escena
            scene.add(mesh);
            objectsToRemove.push(mesh);
          }
        });

        //Carretera2
        const carretera2 = new GLTFLoader();
        carretera2.load('./modelos/road3/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const originalMesh = gltf.scene.children[0];
          originalMesh.position.x = -4620;
          //Repetir carretera
          const numCopies = 500;
          for (let i = 0; i < numCopies; i++) {
            //Clonar el objeto de malla
            const mesh = originalMesh.clone();

            //Modificar la posición del objeto de malla clonado
            mesh.position.x = -4620 + i * -11710; //Distancia entre cada copia de la carretera
            mesh.rotation.z = Math.PI / 2;
            //Escala el objeto de malla
            mesh.scale.set(159, 159, 159);

            //Mueve el objeto de malla hacia arriba en la escena
            mesh.position.y = 47;
            mesh.position.z = -35;
            //Agrega el modelo GLTF a la escena
            scene.add(mesh);
            objectsToRemove.push(mesh);
          }
        });

        //Monedas
        const coin = new GLTFLoader();
        coin.load('./modelos/bitcoin/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const originalMesh = gltf.scene.children[0];
          originalMesh.position.x = -4620;
          //Repetir monedas
          const numCopies = 1000;
          for (let i = 0; i < numCopies; i++) {
            //Clonar el objeto de malla
            const mesh = originalMesh.clone();
            //Modificar la posición del objeto de malla clonado
            mesh.position.x = -2000 + i * -5000; //Distancia entre cada copia de las monedas
            mesh.rotation.z = Math.PI / 2;
            //Escala el objeto de malla
            mesh.scale.set(0.25, 0.25, 0.25);
            //Mueve el objeto de malla hacia arriba en la escena
            mesh.position.y = 110;
            mesh.position.z = Math.random() * 240 - 120; // Genera un número aleatorio entre -120 y 120
            //Agrega el modelo GLTF a la escena
            scene.add(mesh);
            objectsToRemove.push(mesh);
          }
        });

        //Bob Esponja
        const bob = new GLTFLoader();
        bob.load('./modelos/sponge_bob/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const originalMesh = gltf.scene.children[0];
          originalMesh.position.x = -4620;
          //Repetir Bob´s
          const numCopies = 500;
          for (let i = 0; i < numCopies; i++) {
            //Clonar el objeto de malla
            const mesh = originalMesh.clone();
            //Modificar la posición del objeto de malla clonado
            mesh.position.x = -1000 + i * -7000; //Distancia entre cada copia de los Bob´s
            mesh.rotation.z = Math.PI / 2;
            //Escala el objeto de malla
            mesh.scale.set(5, 5, 5);
            //Mueve el objeto de malla hacia arriba en la escena
            mesh.position.y = 127;
            mesh.position.z = Math.random() * 240 - 120; // Genera un número aleatorio entre -120 y 120
            //Agrega el modelo GLTF a la escena
            scene.add(mesh);
            objectsToRemove.push(mesh);
          }
        });

        //Patricio
        const patricio = new GLTFLoader();
        patricio.load('./modelos/sponge-bob-patrick-starfish/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const originalMesh = gltf.scene.children[0];
          originalMesh.position.x = -4620;
          //Repetir Patricio´s
          const numCopies = 500;
          for (let i = 0; i < numCopies; i++) {
            //Clonar el objeto de malla
            const mesh = originalMesh.clone();
            //Modificar la posición del objeto de malla clonado
            mesh.position.x = -2000 + i * -3000; //Distancia entre cada copia de los Patricio´s
            mesh.rotation.z = Math.PI / 2;
            //Escala el objeto de malla
            mesh.scale.set(0.1, 0.1, 0.1);
            //Mueve el objeto de malla hacia arriba en la escena
            mesh.position.y = 112;
            mesh.position.z = Math.random() * 240 - 120; // Genera un número aleatorio entre -120 y 120
            //Agrega el modelo GLTF a la escena
            scene.add(mesh);
            objectsToRemove.push(mesh);
          }
        });

        //Carro oxidado
        const oxidado = new GLTFLoader();
        oxidado.load('./modelos/old_rusty_car/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const originalMesh = gltf.scene.children[0];
          originalMesh.position.x = -4620;
          //Repetir Patricio´s
          const numCopies = 500;
          for (let i = 0; i < numCopies; i++) {
            //Clonar el objeto de malla
            const mesh = originalMesh.clone();
            //Modificar la posición del objeto de malla clonado
            mesh.position.x = -6000 + i * -8000; //Distancia entre cada copia de los Patricio´s
            mesh.rotation.z = Math.PI / 2;
            //Escala el objeto de malla
            mesh.scale.set(0.1, 0.1, 0.1);
            //Mueve el objeto de malla hacia arriba en la escena
            mesh.position.y = 110;
            mesh.position.z = Math.random() * 240 - 120; // Genera un número aleatorio entre -120 y 120
            //Agrega el modelo GLTF a la escena
            scene.add(mesh);
            objectsToRemove.push(mesh);
          }
        });

        //Lamborghini
        /*
        //En la función de carga del objeto GLTF, asignar el objeto a la variable
        const lambo = new GLTFLoader();
        lambo.load('./modelos/free_lamborghini_revuelto/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const mesh = gltf.scene.children[0];
          //Escala el objeto de malla
          mesh.scale.set(30, 30, 30);
          //Mueve el objeto de malla hacia arriba en la escena
          mesh.position.y = 110;
          //Gira el objeto de malla alrededor del eje Z
          mesh.rotation.z = Math.PI / 2;
          //Agrega el modelo GLTF a la escena
          scene.add(gltf.scene);

          //Asignar el objeto a la variable objectToFollow
          objectToFollow = mesh;
          document.addEventListener("keydown", (event) => {
            if (event.code === "ArrowLeft" && (mesh.position.z > -130 && mesh.position.z < 120) && isPaused === false) {
              mesh.position.z += 7;
            } else if (event.code === "ArrowRight" && (mesh.position.z > -120 && mesh.position.z < 130) && isPaused === false) {
              mesh.position.z -= 7;
            }
          });
        });*/

        //delorean
        /*
        //En la función de carga del objeto GLTF, asignar el objeto a la variable
        const delorean = new GLTFLoader();
        delorean.load('./modelos/delorean_from_future/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const mesh = gltf.scene.children[0];
          //Escala el objeto de malla
          mesh.scale.set(0.2, 0.2, 0.2);
          //Mueve el objeto de malla hacia arriba en la escena
          mesh.position.y = 100;
          //Gira el objeto de malla alrededor del eje Z
          mesh.rotation.z = Math.PI;
          //Agrega el modelo GLTF a la escena
          scene.add(gltf.scene);

          //Asignar el objeto a la variable objectToFollow
          objectToFollow = mesh;
          document.addEventListener("keydown", (event) => {
            if (event.code === "ArrowLeft" && (mesh.position.z > -130 && mesh.position.z < 120) && isPaused === false) {
              mesh.position.z += 7;
            } else if (event.code === "ArrowRight" && (mesh.position.z > -120 && mesh.position.z < 130) && isPaused === false) {
              mesh.position.z -= 7;
            }
          });
        });*/

        //mcqueen
    
        //En la función de carga del objeto GLTF, asignar el objeto a la variable
        const mcqueen = new GLTFLoader();
        mcqueen.load('./modelos/lighting_mcqueen/scene.gltf', (gltf) => {
          //Accede al objeto de malla del modelo GLTF
          const mesh = gltf.scene.children[0];
          //Escala el objeto de malla
          mesh.scale.set(10, 10, 10);
          //Mueve el objeto de malla hacia arriba en la escena
          mesh.position.y = 110;
          //Gira el objeto de malla alrededor del eje Z
          mesh.rotation.z = Math.PI / 2 + Math.PI;
          //Agrega el modelo GLTF a la escena
          scene.add(gltf.scene);

          //Asignar el objeto a la variable objectToFollow
          objectToFollow = mesh;

          document.addEventListener("keydown", (event) => {
            if ((event.code === "ArrowLeft" || event.key === "a") && (mesh.position.z > -130 && mesh.position.z < 120) && isPaused === false) {
              mesh.position.z += 7;
            } else if ((event.code === "ArrowRight" || event.key === "d") && (mesh.position.z > -120 && mesh.position.z < 130) && isPaused === false) {
              mesh.position.z -= 7;
            }
          });
        });

        let animationFrameId;

        //En la función de animación, actualizar la posición de la cámara
        function animate() {
          animationFrameId = requestAnimationFrame(animate);

          //Si objectToFollow está definido, actualizar la posición de la cámara
          if (objectToFollow) {
            //Mover hacia adelante
            objectToFollow.position.x -= speed;
            // Actualizar el valor de las monedas
            const coinsValue = document.getElementById('coinsValue');
            coinsValue.textContent = monedas;
            // Actualizar el valor del puntaje
            const scoreValue = document.getElementById('scoreValue');
            scoreValue.textContent = puntos++;
            // Actualizar el valor de las vidas
            const livesValue = document.getElementById('livesValue');
            livesValue.textContent = vidas;
            //Actualizar la posición de la cámara para que esté detrás del objeto
            camera.position.set(objectToFollow.position.x + 120, objectToFollow.position.y + 60, objectToFollow.position.z);
            //Apuntar la cámara hacia el objeto
            camera.lookAt(objectToFollow.position);
            for (let i = objectsToRemove.length - 1; i >= 0; i--) {
              const object = objectsToRemove[i];
              if (object.position.x > objectToFollow.position.x + 3500) {
                scene.remove(object);
                objectsToRemove.splice(i, 1);
              }
            }
          }

          renderer.render(scene, camera);
        }

        //Agregar variable de pausa
        let isPaused = false;
        let alto; // Variable para almacenar el objeto GLTF "alto"
        let audio = document.querySelector('audio'); // Obtener referencia al elemento audio

        // Carga el objeto GLTF "alto" fuera del evento de pausa
        const cargarAlto = () => {
            const loader = new GLTFLoader();
            loader.load('./modelos/rusty_stop_sign/scene.gltf', (gltf) => {
              // Accede al objeto de malla del modelo GLTF
              const mesh = gltf.scene.children[0];
              // Escala el objeto de malla
              mesh.scale.set(0.2, 0.2, 0.2);
              // Mueve el objeto de malla hacia arriba en la escena
              mesh.position.y = 110;
              // Gira el objeto de malla alrededor del eje Z
              mesh.rotation.z = Math.PI / 2;
              mesh.position.x = objectToFollow.position.x + 10;
              mesh.position.z = objectToFollow.position.z;
              // Agrega el modelo GLTF a la escena
              scene.add(mesh);
              alto = mesh; // Asigna el objeto GLTF "alto" a la variable
            });
          };

        //Controlador de eventos para la tecla "p"
        document.addEventListener('keydown', function (event) {
          if (event.key === 'p') {
            isPaused = !isPaused; //cambiar el estado de pausa

            //pausar/reanudar la animación
            if (isPaused) {
              cargarAlto(); // Llama a la función para cargar el objeto "alto"
              cancelAnimationFrame(animationFrameId); //Detiene el bucle de animación
              audio.pause(); // Pausa el audio
            } else {
              animationFrameId = requestAnimationFrame(animate); //Reanuda el bucle de animación
              scene.remove(alto); // Elimina el objeto "alto" de la escena
              audio.play(); // Reproduce el audio
            }
          }
        });

        document.addEventListener('keydown', (event) => {
          if (event.code === 'Space' && isPaused === false)
            // Reproducir el audio
            cuchao.play();
        });
        //Crear controles de órbita
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.update();
        animate();
        if (audio)
          audio.play();
      }             
    </script>
  </body>
</html>